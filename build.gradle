apply from: 'config/gradle/ide.gradle'

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        // Git plugin for Gradle
        classpath 'org.ajoberstar:gradle-git:0.6.3'
    }
}
// Git plugin details at https://github.com/ajoberstar/gradle-git
import org.ajoberstar.gradle.git.tasks.*

allprojects {
    apply plugin: 'eclipse'
    apply plugin: 'idea'

    version = '2.0.0'
    ext {
        appName = 'DestinationSol'
        gdxVersion = '1.9.8'
        roboVMVersion = '2.3.3'
    }
}

repositories {
    // Good ole Maven central
    mavenCentral()

    // Repos for LibGDX
    maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
    maven { url "https://oss.sonatype.org/content/repositories/releases/" }

    // Terasology Artifactory for any shared libs
    maven { url "http://artifactory.terasology.org/artifactory/virtual-repo-live" }
}

configurations {
    codeMetrics
}

dependencies {
    // Config for our code analytics lives in a centralized repo: https://github.com/MovingBlocks/TeraConfig
    codeMetrics group: 'org.terasology.config', name: 'codemetrics', version: '1.2.0', ext: 'zip'
}

task extractConfig(type: Copy) {
    description = "Extracts our configuration files from the zip we fetched as a dependency"
    from {
        configurations.codeMetrics.collect {
            zipTree(it)
        }
    }
    into "$rootDir/config/metrics"
}


// Helper that returns a list of all local Destination Sol module projects
def destinationSolModules() {
    subprojects.findAll {it.parent.name == 'modules'}
}

tasks.eclipse.doLast {
    delete ".project"
}

idea {
    project {
        // Set JDK
        jdkName = '1.8'
        wildcards -= '!?*.groovy'

        ipr {
            withXml { xmlProvider ->
                // Apply a bunch of tweaks to IntelliJ config - all defined in ide.gradle
                // Part reason for separate file was in case a module needs to define something it cannot do so in a project block
                def iprNode = xmlProvider.asNode()
                ideaActivateCheckstyle(iprNode)
                ideaActivateCopyright(iprNode)
                ideaActivateAnnotations(iprNode)
                ideaActivateGit(iprNode)
                ideaActivateGradle(iprNode)
            }

            // Sets sourceCompatibility within IntelliJ (without this root build having the Java plugin applied)
            whenMerged { project ->
                project.jdk.languageLevel = 'JDK_1_8'
            }
        }
    }

    // Tweaks to the .iws
    workspace.iws.withXml { xmlProvider ->
        def iwsNode = xmlProvider.asNode()
        ideaMakeAutomatically(iwsNode)
        ideaRunConfig(iwsNode)
    }
}

cleanIdea.doLast {
    new File('DestinationSol.iws').delete()
    new File('config/metrics').deleteDir()
    println "Cleaned root - don't forget to re-extract code metrics config! 'gradlew extractConfig' will do so, or 'gradlew idea' (or eclipse)"
}

task(fetchAndroid, type: GitClone) {
    description = 'Git clones the Android facade source from GitHub'

    // Repo name is the dynamic part of the task name
    def repo = 'DestSolAndroid'

    // Default GitHub account to use. Supply with -PgithubAccount="TargetAccountName" or via gradle.properties
    def githubHome = 'MovingBlocks'

    def destination = file('android')

    // Don't clone this repo if we already have a directory by that name (also determines Gradle UP-TO-DATE)
    enabled = !destination.exists()
    //println "fetchAndroid requested for $repo from Github under $githubHome - exists already? " + !enabled

    // Do the actual clone if we don't have the directory already
    if (enabled) {
        uri = "https://github.com/$githubHome/" + repo + ".git"
        //println "Fetching $repo from $uri"
        destinationPath = destination
        bare = false
    } else {
        throw new StopActionException("The repository $repo already exists. To re-clone the repository, delete the ${destination.name} folder and try again.")
    }
}

task(fetchGwt, type: GitClone) {
    description = 'Git clones the GWT facade source from GitHub'

    // Repo name is the dynamic part of the task name
    def repo = 'DestSolGwt'

    // Default GitHub account to use. Supply with -PgithubAccount="TargetAccountName" or via gradle.properties
    def githubHome = 'MovingBlocks'

    def destination = file('gwt')

    // Don't clone this repo if we already have a directory by that name (also determines Gradle UP-TO-DATE)
    enabled = !destination.exists()
    //println "fetchGwt requested for $repo from Github under $githubHome - exists already? " + !enabled

    // Do the actual clone if we don't have the directory already
    if (enabled) {
        uri = "https://github.com/$githubHome/" + repo + ".git"
        //println "Fetching $repo from $uri"
        destinationPath = destination
        bare = false
    } else {
        throw new StopActionException("The repository $repo already exists. To re-clone the repository, delete the ${destination.name} folder and try again.")
    }
}

task(fetchGestalt, type: GitClone) {
    description = 'Git clones the gestalt Android source from GitHub'

    def repo = 'gestalt'
    def githubHome = 'MovingBlocks'
    def destination = file('gestalt')

    enabled = !destination.exists()

    if (enabled) {
        uri = "https://github.com/$githubHome/" + repo + ".git"
        destinationPath = destination
        bare = false
        branch = 'android'
    } else {
        throw new StopActionException("The repository $repo already exists. To re-clone the repository, delete the ${destination.name} folder and try again.")
    }
}

task(fetchReflections, type: GitClone) {
    description = 'Git clones the org.reflections.reflections source from GitHub'

    def repo = 'reflections'
    def githubHome = 'ronmamo'
    def destination = file('gestalt-reflections')

    enabled = !destination.exists()

    if (enabled) {
        uri = "https://github.com/$githubHome/" + repo + ".git"
        destinationPath = destination
        bare = false
    } else {
        throw new StopActionException("The repository $repo already exists. To re-clone the repository, delete the ${destination.name} folder and try again.")
    }
}

fetchGestalt.doLast {
    new File("$rootDir/gestalt", "gradle.properties").text = "version=7.0.0-SNAPSHOT"
    def localPropertiesFile = new File("$rootDir", "local.properties")
    if (localPropertiesFile.exists()) {
        new File("$rootDir/gestalt", "local.properties").text = localPropertiesFile.text
    }

    File fileToPatch = new File("$rootDir/gestalt/gestalt-android-testbed/src/main/java/org/terasology/gestalt/android/testbed", "GestaltTestActivity.java")
    fileToPatch.text = fileToPatch.text.replace("new ReflectionComponentTypeFactory()", "new ComponentManager()")
                       .replace("org.terasology.entitysystem.component.ReflectionComponentTypeFactory", "org.terasology.entitysystem.component.ComponentManager");


    def gradleCommand = System.getProperty("os.name").toLowerCase().contains("windows") ? "gradlew.bat" : "gradlew"
    exec {
        workingDir "$rootDir/gestalt"
        commandLine "$rootDir/gestalt/$gradleCommand", 'assemble', '-x', ':gestalt-android-testbed:assemble'
    }
}

fetchReflections.doLast {
    def gradleCommand = System.getProperty("os.name").toLowerCase().contains("windows") ? "gradlew.bat" : "gradlew"
    exec {
        workingDir "$rootDir/gestalt-reflections"
        commandLine "$rootDir/$gradleCommand", 'init', '--type', 'pom'
    }
    exec {
        workingDir "$rootDir/gestalt-reflections"
        commandLine "$rootDir/$gradleCommand", 'jar', 'install'
    }
}

fetchAndroid.dependsOn fetchGestalt
fetchGestalt.dependsOn fetchReflections

task wrapper(type: Wrapper) {
    gradleVersion = '2.10'
}
